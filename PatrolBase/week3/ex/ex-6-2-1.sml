

(* ========================================================================== *)
(*                                                                            *)
(* Enter the HOL equivalent of P(x) ⊃ Q(y).                                   *)
(*                                                                            *)
(* ========================================================================== *)

``x``;
``P x``;
``Q y ``;
``P x ==> y ``;
``P x ==> Q y ``;

<<HOL message: inventing new type variable names: 'a, 'b>>
val it =
   “(P :'a -> bool) (x :'a) ==> (Q :'b -> bool) (y :'b)”:
   term

%x = 'a, and P is a function that takes in 'a and turn it into a bool variable
%y = 'b, and Q is a function that takes in 'b and turn it into a bool variable
%This function is the function of P('a) implies Q('b)




``P (x:num) ==> Q (y:bool) ``;

val it =
   “(P :num -> bool) (x :num) ==> (Q :bool -> bool) (y :bool)”:
   term
   
?????????????????????????????????????????????????????????????
``!x y.P x ==> Q y ``;

<<HOL message: inventing new type variable names: 'a, 'b>>
val it =
   “!(x :'a) (y :'b). (P :'a -> bool) x ==> (Q :'b -> bool) y”:
   term
???????????????????????????????????????????????????????????????????
``@(x:num).R(x:'a)``;
??????????????????????????????????????????????????????????????????
``~!x.P x \/ Q x = @x.~P x /\ ~Q x ``;

val it =
   “~!(x :bool).
    (P :bool -> bool) x \/ (Q :bool -> bool) x <=>
    @(x :bool). ~P x /\ ~Q x”:
   term
???????????????????????????????????????????????????????????????????
``!x.P x ==> M x``;

<<HOL message: inventing new type variable names: 'a>>
val it =
   “!(x :'a). (P :'a -> bool) x ==> (M :'a -> bool) x”:
   term
////////////////////////////////////////////////////////////////////

``@x.Funny x``;

val it =
   “@(x :'a). (Funny :'a -> bool) x”:
   term